#ifndef LIB_MASTERWORKER_MASTERWORKER_HPP
#define LIB_MASTERWORKER_MASTERWORKER_HPP

/**

  Due to limitations in the serialization library and the requirement to send
  different types to one MPI call, base classes are used in the design of this
  library.

    +----------------+
    |    wrapper     |
    +-------X--------+
           /|\
            |
    +-------+--------+
    |     base       |
    +-------X--------+
           /|\
            |
    +-------+--------+
    |function_wrapper| <- generated by macro
    +----------------+

  The macro generates:

   * the header for a functor masterworker::functionname::operator() that is
     completed by the user
   * a helper class worker::functionname that contains information about how to
     generate the wrapper for the function to call, the parameters and the
     return type; it is also used to run the worker function, as it is passed as
     a template argument to the run and async_run functions
   * a functionname_wrapper class, that inherits from base, implements the
     execute function and has the parameters (fusion::vector) and return value
      as members
   * the struct masterworker::functionname that contains two communicators and
     the prototype for the operator()

  function_wrapper inherits from base to get a typeless interface
  wrapper contains a pointer to base

*/

#include <lib/masterworker/base.hpp>
#include <lib/masterworker/master.hpp>
#include <lib/masterworker/worker.hpp>
#include <lib/masterworker/worker_function.hpp>
#include <lib/masterworker/wrapper.hpp>

#endif // LIB_MASTERWORKER_MASTERWORKER_HPP

